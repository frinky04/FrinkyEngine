# Agent Instructions

## Build & Run

| Command | Description |
|---------|-------------|
| `dotnet build FrinkyEngine.sln` | Build all projects |
| `dotnet run --project src/FrinkyEngine.Editor` | Run editor |
| `dotnet run --project src/FrinkyEngine.Editor -- path/to/Game.fproject` | Open specific project |
| `dotnet run --project src/FrinkyEngine.Runtime -- path/to/Game.fproject` | Run game |

No tests exist.

## Commit Attribution

AI commits MUST include:
```
Co-Authored-By: (the agent model's name and attribution byline)
```

## Project Layout

- `src/FrinkyEngine.Core/` — shared engine library (entities, components, scene, serialization, rendering)
- `src/FrinkyEngine.Editor/` — ImGui desktop editor
- `src/FrinkyEngine.Runtime/` — standalone game player
- `templates/FrinkyEngine.Templates/` — `dotnet new` template pack

## Key Conventions

- .NET 8, C# 12, nullable enabled, `AllowUnsafeBlocks=true`
- File-scoped namespaces
- Components in `Components/`, panels in `Panels/`, serialization in `Serialization/`
- Scenes: `.fscene`, Prefabs: `.fprefab`, Projects: `.fproject` (all JSON)
- Public Core API types/methods get `<summary>` XML docs; Editor/Runtime internals do not
- Update `/docs` when adding new features
- Do not update `/docs/api` — it is auto-regenerated by a git workflow on build

## Console Commands

When adding a new system or feature, evaluate whether it benefits from console commands or CVars.

- Registration: `ConsoleBackend.RegisterCommand()` / `ConsoleBackend.RegisterCVar(new ConsoleCVar(...))`
- All registration happens in `EngineOverlays.EnsureConsoleBackendInitialized()` (`src/FrinkyEngine.Core/UI/EngineOverlays.cs`)
- Runtime cvar state in dedicated static classes (e.g. `RenderRuntimeCvars`)
- Naming: `prefix_name` — `r_` rendering, `snd_` audio, `physics_` physics

## Serialization Pitfalls

- `SceneSerializer` and `PrefabSerializer` each have independent `JsonOptions` with converters — register new type converters in BOTH

## API Pitfalls

- **Raylib-cs `Shader.Locs`** is a pointer — use `unsafe`, cache locations in `int` fields
- **Hexa.NET.ImGui** — namespace `Hexa.NET.ImGui`, use `ImGuiP` for docking APIs, many overloads need `(string?)null` casts, images use `ImTextureRef`
- **Hexa.NET.ImGui.Widgets** — `ComboEnumHelper<T>.Combo()` / `ComboEnumHelper.Combo()` for enum combos, `MessageBoxes.Show()` / `MessageBoxes.Draw()` for modal dialogs
- **RlImGui** (custom `RlImGui.cs`) — call `Rlgl.DrawRenderBatchActive()` after each draw command in `End()`
- **Raylib cursor** — `DisableCursor()`/`EnableCursor()` re-center mouse; only call on state transitions

## Editor Keybinds

- **Never use raw `ImGui.IsKeyPressed()`** for editor shortcuts — always use `KeybindManager` + `EditorAction` enum so keybinds are rebindable
- Panel-specific actions: check `IsWindowFocused` in the keybind callback to dispatch per-panel (see `EditorAction.RenameEntity` for pattern)
- Context menus: use `KeybindManager.Instance.GetShortcutText(EditorAction.X)` for shortcut labels, not hardcoded strings
- By default, keybinds are **disabled in Play mode**. Whitelisted actions: `PlayStop`, `SimulateStop`, `ToggleGameView`, `TogglePlayModeCursorLock`, `FrameSelected`, `DeselectEntity`, `TogglePhysicsHitboxPreview`
- To allow a new keybind in Play mode, add it to `KeybindManager.CanProcessActionInCurrentMode()`
