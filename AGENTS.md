# Agent Instructions

## Docs and Agent MD
In order to keep a coherent structure, anytime you use a workaround, or want an agent from the future to know anything, update the AGENTS.md with that information. Information can be lost between agent sessions, so its essential to keep this updated. Information should not be lost!

## Build & Run

| Command | Description |
|---------|-------------|
| `dotnet build FrinkyEngine.sln` | Build all projects |
| `dotnet run --project src/FrinkyEngine.Editor` | Run editor |
| `dotnet run --project src/FrinkyEngine.Editor -- path/to/Game.fproject` | Open specific project |
| `dotnet run --project src/FrinkyEngine.Runtime -- path/to/Game.fproject` | Run game |

No tests exist.

## Commit Attribution

AI commits MUST include:
```
Co-Authored-By: (the agent model's name and attribution byline)
```

## Project Layout

- `src/FrinkyEngine.Core/` — shared engine library (entities, components, scene, serialization, rendering)
- `src/FrinkyEngine.Editor/` — ImGui desktop editor
- `src/FrinkyEngine.Runtime/` — standalone game player
- `templates/FrinkyEngine.Templates/` — `dotnet new` template pack

## Key Conventions

- .NET 8, C# 12, nullable enabled, `AllowUnsafeBlocks=true`
- File-scoped namespaces
- Components in `Components/`, panels in `Panels/`, serialization in `Serialization/`
- Scenes: `.fscene`, Prefabs: `.fprefab`, Projects: `.fproject` (all JSON)
- Public Core API types/methods get `<summary>` XML docs; Editor/Runtime internals do not
- Update `/docs` when adding new features
- Do not update `/docs/api` — it is auto-regenerated by a git workflow on build

## Console Commands

When adding a new system or feature, evaluate whether it benefits from console commands or CVars.

- Registration: `ConsoleBackend.RegisterCommand()` / `ConsoleBackend.RegisterCVar(new ConsoleCVar(...))`
- `EngineOverlays.EnsureConsoleBackendInitialized()` now delegates registration to `EngineConsoleRegistrar.RegisterAll(...)` in `src/FrinkyEngine.Core/UI/Console/EngineConsoleRegistrar.cs`
- Runtime cvar state in dedicated static classes (e.g. `RenderRuntimeCvars`)
- Naming: `prefix_name` — `r_` rendering, `snd_` audio, `physics_` physics

## Serialization Pitfalls

- `SceneSerializer` and `PrefabSerializer` each have independent `JsonOptions` with converters — register new type converters in BOTH

## API Pitfalls

- **Raylib-cs `Shader.Locs`** is a pointer — use `unsafe`, cache locations in `int` fields
- **Raylib animation math conventions** — for skinning-critical codepaths, prefer `Raymath.MatrixMultiply/MatrixInvert/QuaternionToMatrix/...` over hand-rolled `System.Numerics` composition; matrix order assumptions are easy to get wrong and can cause catastrophic mesh deformation
- **IK pose spaces** — sample animation, convert to local-space, run IK in local-space, then convert back to model-space for skinning matrix reconstruction; avoid interpolating IK input in model-space
- **IK activation gating** — only run IK pipeline when at least one solver is truly runnable for the current hierarchy (not merely present/enabled), otherwise stay on the non-IK animation path
- **ImGuizmo state is global** — if multiple gizmo paths exist (entity transform + inspector handle), never gate one path on `ImGuizmo.IsUsing()` from the other path; choose one active path explicitly and call only that manipulator for the frame
- **RLGL depth state + batching** — when toggling depth test for editor overlays (e.g. bones on top), call `Rlgl.DrawRenderBatchActive()` before and after the overlay draw block; otherwise mixed batch flush timing can cause partial/unstable depth ordering
- **Hexa.NET.ImGui** — namespace `Hexa.NET.ImGui`, use `ImGuiP` for docking APIs, many overloads need `(string?)null` casts, images use `ImTextureRef`
- **Hexa.NET.ImGuizmo bounds editing (collider mode)** — for box-collider face-drag resize with automatic center compensation, use `ImGuizmoOperation.Bounds` with a TR-only matrix and a mutable 6-float `localBounds` array (`minX,minY,minZ,maxX,maxY,maxZ`) in world units; convert updated bounds + matrix translation back to collider `Size`/`Center`
- **Hexa.NET.ImGuizmo bounds caveat** — `localBounds` is input-only (not mutated). For editable box colliders, feed unit bounds (`-0.5..0.5`) and read updated size/offset from the manipulated matrix scale/translation.
- **Hexa.NET.ImGuizmo bounds caveat #2** — in Bounds mode, `changed`/`matrix` can be stale on some active frames; when interacting (`ImGuizmo.IsUsing()`), fall back to composing `deltaMatrix * originalMatrix` if `matrix` stayed unchanged.
- **Box collider edit UX** — use `ImGuizmoOperation.Bounds | ImGuizmoOperation.Translate` so face-drag resize and direct center offset both work in collider edit mode.
- **Hexa.NET.ImGui.Widgets** — `ComboEnumHelper<T>.Combo()` / `ComboEnumHelper.Combo()` for enum combos, `MessageBoxes.Show()` / `MessageBoxes.Draw()` for modal dialogs
- **RlImGui** (custom `RlImGui.cs`) — call `Rlgl.DrawRenderBatchActive()` after each draw command in `End()`
- **Raylib cursor** — `DisableCursor()`/`EnableCursor()` re-center mouse; only call on state transitions
- **CanvasUI panel lifecycle** — `Panel.AddChild(Panel child)` must invoke `OnCreated()` for first-time attachments; reparenting existing initialized panels should not re-run creation hooks
- **CanvasUI hit testing + overflow clip** — hit testing must respect ancestor `overflow: hidden` clipping so visually clipped/scrolled-out children are not interactive
- **CanvasUI font fallback ownership** — if `FontManager` falls back to `Raylib.GetFontDefault()`, treat it as engine-owned and never unload it
- **CanvasUI wheel bubbling** — `OnMouseWheel` now uses `MouseWheelEvent` (`Delta`, `Handled`); set `Handled = true` only when scroll was actually consumed, otherwise allow ancestor scroll containers to receive the wheel event
- **CanvasUI markup bindings** — `.canvas` supports one-way `{Property}` bindings only (context -> UI) and event handlers resolved by method name on the active `BindingContext`; two-way binding is not implemented
- **CanvasUI `context` attribute** — only binding syntax is supported (`context="{ChildVm}"`); static string context values are ignored with a warning
- **Asset typing for CanvasUI files** — `.canvas` files are currently indexed as `AssetType.Script` so they remain visible when "Hide Unrecognised Assets" is enabled and open in the existing script flow

## Current Workarounds

- **Asset icon generation cadence** — icon generation is intentionally throttled in `AssetIconService` (`MinJobIntervalSeconds = 0.2`) to keep editor frame impact low; adjust this constant if startup icon warmup speed is preferred over smoother frame pacing.

## Editor Keybinds

- **Never use raw `ImGui.IsKeyPressed()`** for editor shortcuts — always use `KeybindManager` + `EditorAction` enum so keybinds are rebindable
- Panel-specific actions: check `IsWindowFocused` in the keybind callback to dispatch per-panel (see `EditorAction.RenameEntity` for pattern)
- Context menus: use `KeybindManager.Instance.GetShortcutText(EditorAction.X)` for shortcut labels, not hardcoded strings
- By default, keybinds are **disabled in Play mode**. Whitelisted actions: `PlayStop`, `SimulateStop`, `ToggleGameView`, `TogglePlayModeCursorLock`, `FrameSelected`, `DeselectEntity`, `TogglePhysicsHitboxPreview`
- To allow a new keybind in Play mode, add it to `KeybindManager.CanProcessActionInCurrentMode()`
